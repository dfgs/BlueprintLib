using BlueprintLib.Definitions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Scriban;
using Scriban.Runtime;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Reflection.Metadata;
using System.Runtime.CompilerServices;
using System.Text;
using System.Xml.Linq;
using static System.Net.Mime.MediaTypeNames;


namespace BlueprintLib
{

	
	[Generator]
	public class CodeGenerator : IIncrementalGenerator
	{
		public const string Namespace = "BlueprintLib.Attributes";
		
		public const string BlueprintAttributeName = "BlueprintAttribute";
		public const string BlueprintFullAttributeName = $"{Namespace}.{BlueprintAttributeName}";
		
		public const string DTOAttributeName = "DTOAttribute";
		public const string DTOFullAttributeName = $"{Namespace}.{DTOAttributeName}";

		private string BlueprintAttributeSourceCode =
        $$"""
		// <auto-generated/>
		using System;
		
		namespace {{Namespace}}
		{
			[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = true)]
			internal class {{BlueprintAttributeName}} : Attribute
			{
				public string Name
				{
					get;
					set;
				}
				public {{BlueprintAttributeName}}(string Name)
				{
					this.Name=Name;
				}
			}
		}
		""";
		private string DTOAttributeSourceCode =
		$$"""
		// <auto-generated/>
		using System;
		
		namespace {{Namespace}}
		{
			[AttributeUsage(AttributeTargets.Class| AttributeTargets.Interface, AllowMultiple = true)]
			internal class {{DTOAttributeName}} : Attribute
			{
				public string Name
				{
					get;
					set;
				}
				public {{DTOAttributeName}}(string Name)
				{
					this.Name=Name;
				}
			}
		}
		""";

		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			IncrementalValuesProvider<Blueprint> blueprintFileProvider;
			IncrementalValuesProvider<DTO> dtoFileProvider;
			IncrementalValuesProvider<TypeDeclarationSyntax> typeDeclarationSyntaxProvider;
			IncrementalValuesProvider<string> referencesProvider;


			// register static files
			context.RegisterPostInitializationOutput(incrementalGeneratorPostInitializationContext => incrementalGeneratorPostInitializationContext.AddSource($"Attributes/{BlueprintAttributeName}.g.cs", SourceText.From(BlueprintAttributeSourceCode, Encoding.UTF8)));
			context.RegisterPostInitializationOutput(incrementalGeneratorPostInitializationContext => incrementalGeneratorPostInitializationContext.AddSource($"Attributes/{DTOAttributeName}.g.cs", SourceText.From(DTOAttributeSourceCode, Encoding.UTF8)));

			// provide dependency dlls
			referencesProvider = context.MetadataReferencesProvider.Where(metadataReference => metadataReference is CompilationReference compilationReference)
			.Select((assemblyMetadata, cancellationToken) => 
				assemblyMetadata.Display??"Undefined"
			);

			// provide blueprint files
			blueprintFileProvider = context.AdditionalTextsProvider.Where(additionalText => Path.GetExtension(additionalText.Path) == ".bp")
			.Select((additionalText, cancellationToken) =>
				new Blueprint(Path.GetFileNameWithoutExtension(additionalText.Path), additionalText.GetText(cancellationToken)?.ToString() ?? "// No content")
			);

			// provide DTO files
			dtoFileProvider = context.AdditionalTextsProvider.Where(additionalText => Path.GetExtension(additionalText.Path) == ".dto")
			.Select((additionalText, cancellationToken) =>
				DTOSerializer.Deserialize(additionalText.Path)
			);


			#pragma warning disable CS8619 // La nullabilité des types référence dans la valeur ne correspond pas au type cible.
			typeDeclarationSyntaxProvider = context.SyntaxProvider.CreateSyntaxProvider
			(
				(syntaxNode, cancellationToken) => (syntaxNode is ClassDeclarationSyntax classDeclatationSyntax) || (syntaxNode is InterfaceDeclarationSyntax interfaceDeclatationSyntax),
				transform: static (GeneratorSyntaxContext, _) => GeneratorSyntaxContext.Node as TypeDeclarationSyntax
			)
			.Where(typeDeclarationSyntax => typeDeclarationSyntax != null);
			#pragma warning restore CS8619 // La nullabilité des types référence dans la valeur ne correspond pas au type cible.

			
			IncrementalValueProvider<ProjectDefinition> projectDefinitionProvider =
				context.CompilationProvider
				.Combine(referencesProvider.Collect())
				.Combine(typeDeclarationSyntaxProvider.Collect())
				.Combine(dtoFileProvider.Collect())
				.Select((combined, cancelationToken) => GenerateProjectDefinition(combined.Left.Left.Left,combined.Left.Left.Right, combined.Left.Right,combined.Right));

			IncrementalValueProvider<(ProjectDefinition ProjectDefinition, ImmutableArray<Blueprint> Blueprints)> sourceContextProvider =
				projectDefinitionProvider.
				Combine(blueprintFileProvider.Collect())
				.Select((combined, cancellationToken) => (combined.Left, combined.Right));

			context.RegisterSourceOutput
			(
				sourceContextProvider,
				(sourceProductionContext, combined) => GenerateDynamicSources(sourceProductionContext, combined.ProjectDefinition,combined.Blueprints)
			);

		}

		private static IEnumerable<AttributeDefinition> GenerateAttributeDefinitions(ISymbol Symbol) 
		{
			AttributeDefinition attributeDefinition;
			AttributeParameterDefinition attributeParameterDefinition;

			foreach (AttributeData attributeData in Symbol.GetAttributes())
			{
				if (attributeData.AttributeClass == null) continue;
				attributeDefinition = new AttributeDefinition(attributeData.AttributeClass.ToString());

				if (attributeData.AttributeConstructor != null)
				{
					for (int t = 0; t < attributeData.AttributeConstructor.Parameters.Length; t++)
					{
						string parameterName = attributeData.AttributeConstructor.Parameters[t].Name;
						string? parameterValue = attributeData.ConstructorArguments[t].Value?.ToString();

						attributeParameterDefinition = new AttributeParameterDefinition(parameterName, parameterValue);
						attributeDefinition.Parameters.Add(attributeParameterDefinition);
					}
				}
				foreach (KeyValuePair<string, TypedConstant> namedArgument in attributeData.NamedArguments)
				{
					string parameterName = namedArgument.Key;
					string? parameterValue = namedArgument.Value.Value?.ToString();

					attributeParameterDefinition = new AttributeParameterDefinition(parameterName, parameterValue);
					attributeDefinition.Parameters.Add(attributeParameterDefinition);
				}

				yield return attributeDefinition;
			}
		}
		private static IEnumerable<PropertyDefinition> GeneratePropertyDefinitions(INamedTypeSymbol TypeSymbol)
		{
			PropertyDefinition propertyDefinition;
			

			foreach (IPropertySymbol propertySymbol in TypeSymbol.GetMembers().OfType<IPropertySymbol>())
			{
				propertyDefinition = new PropertyDefinition(propertySymbol.Name,propertySymbol.Type.ToString());
				propertyDefinition.Attributes.AddRange(GenerateAttributeDefinitions(propertySymbol));
				yield return propertyDefinition;
			}
		}

		private static ProjectDefinition GenerateProjectDefinition(Compilation Compilation,ImmutableArray<string> References,  ImmutableArray<TypeDeclarationSyntax> TypeDeclarations, ImmutableArray<DTO> DTOs)
		{
			INamedTypeSymbol? typeSymbol;
			string nameSpace;
			string className;

			ProjectDefinition projectDefinition ;
			ClassDefinition classDefinition;
			DTO? dto;


			projectDefinition = new ProjectDefinition(Compilation.AssemblyName??"noname");
			projectDefinition.References.AddRange(References);

			foreach (TypeDeclarationSyntax typeDeclaration in TypeDeclarations)
			{
				// On récupère le modèle sémantique pour pouvoir manipuler les méta données et le contenu de nos objets 
				typeSymbol = typeDeclaration.GetTypeSymbol<INamedTypeSymbol>(Compilation);
				if (typeSymbol == null) continue;

				// On récupère le namespace, le nom du noeud courant et on créé le nom du futur DTO
				nameSpace = typeSymbol.ContainingNamespace.ToDisplayString();
				className = typeDeclaration.Identifier.Text;
				classDefinition=new ClassDefinition(nameSpace, className);
				projectDefinition.Classes.Add(classDefinition);

				classDefinition.Attributes.AddRange(GenerateAttributeDefinitions(typeSymbol));
				classDefinition.Properties.AddRange(GeneratePropertyDefinitions(typeSymbol));

				// get additional DTO
				foreach (AttributeDefinition attributeDefinition in classDefinition.Attributes.Where(item => item.Name == DTOFullAttributeName).ToArray())
				{
					foreach (AttributeParameterDefinition attributeParameterDefinition in attributeDefinition.Parameters.Where(item => item.Name == "Name").ToArray())
					{
						if (attributeParameterDefinition.Value == null) continue;
						dto = DTOs.FirstOrDefault(item => item.Name == attributeParameterDefinition.Value);
						if (dto == null) continue;
						classDefinition.Properties.AddRange(dto.Properties);
						classDefinition.Attributes.AddRange(dto.Attributes);
					}
				}

			}

			return projectDefinition;
		}

		private static string GenerateSourceContent(string TemplateContent, TemplateContext TemplateContext)
		{
			string source;

			Template template = Scriban.Template.Parse(TemplateContent);
			if (template.HasErrors) source = $"/* \r\nErrors found in blueprint:\r\n{template.Messages.ToString()}\r\n*/";
			else
			{
				try
				{
					source = template.Render(TemplateContext);
				}
				catch (Exception e)
				{
					source = $"/* \r\nErrors found in blueprint:\r\n{e.Message}\r\n*/";
				}

			}

			return source;
		}

		

		private void GenerateDynamicSources(SourceProductionContext SourceProductionContext,ProjectDefinition ProjectDefinition, ImmutableArray<Blueprint> Blueprints)
		{
			IEnumerable<Blueprint> blueprints;
			string source;
			TemplateContext templateContext;
			ScriptObject scriptObject;


			templateContext = new TemplateContext();

			scriptObject = new ScriptObject();
			// Declare a functions
			scriptObject.Import("find", (IEnumerable<INamed>  items, string name) => items.Find(name) );
			scriptObject.Import("contains", (IEnumerable<INamed> items, string name) => items.Contains(name) );
			scriptObject.Import("with_attribute", (IEnumerable<IAttributeContainer> items, string name) => items.WithAttribute(name).ToArray() );

			scriptObject.Add("project", ProjectDefinition);

			templateContext.PushGlobal(scriptObject);

			// generate source files from project definition
			foreach (ClassDefinition classDefinition in ProjectDefinition.Classes)
			{
				// generate source from all defined blueprints
				foreach (AttributeDefinition attributeDefinition in classDefinition.Attributes.Where(item=>item.Name == BlueprintFullAttributeName))
				{
					foreach (AttributeParameterDefinition attributeParameterDefinition in attributeDefinition.Parameters.Where(item => item.Name == "Name"))
					{
						if (attributeParameterDefinition.Value == null) continue;
						if (attributeParameterDefinition.Value.EndsWith("*"))
						{
							string maskedName = attributeParameterDefinition.Value.Trim('*');
							blueprints = Blueprints.Where(item => item.FileName.StartsWith(maskedName));
						}
						else
						{
							blueprints = Blueprints.Where(item => item.FileName == attributeParameterDefinition.Value);
						}

						if ((blueprints!=null) && (blueprints.Any()))
						{
							foreach (Blueprint blueprint in blueprints)
							{
								scriptObject.Remove("class");
								scriptObject.Add("class", classDefinition);
								source = GenerateSourceContent(blueprint.Content, templateContext);

								SourceProductionContext.AddSource($"{classDefinition.Name}.{blueprint.FileName}.g.cs", SourceText.From(source, Encoding.UTF8));
							}
						}
						else
						{
							source = $"#warning Blueprint {attributeParameterDefinition.Value} was not found, please check if compilation action is set to additional files";
							SourceProductionContext.AddSource($"{classDefinition.Name}.{Path.GetFileName(attributeParameterDefinition.Value.Trim('*'))}.g.cs", SourceText.From(source, Encoding.UTF8));
						}

					}
				}
			}

			
        }

 

    }
}