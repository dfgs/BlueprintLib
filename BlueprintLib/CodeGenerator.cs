using BlueprintLib.Definitions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Xml.Linq;
using static System.Net.Mime.MediaTypeNames;


namespace BlueprintLib
{

	
	[Generator]
	public class CodeGenerator : IIncrementalGenerator
	{
		
        private const string ClassBlueprintAttributeSourceCode =
        $$"""
		// <auto-generated/>
		using System;
		
		namespace BlueprintLib.Attributes
		{
			[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
			public class ClassBlueprintAttribute : Attribute
			{
				public string Name
				{
					get;
					set;
				}
				public ClassBlueprintAttribute(string Name)
				{
					this.Name=Name;
				}
			}
		}
		""";

        public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			IncrementalValuesProvider<Blueprint> blueprintFileProvider;
			IncrementalValuesProvider<TypeDeclarationSyntax> typeDeclarationSyntaxProvider;


			// register static files
			context.RegisterPostInitializationOutput(incrementalGeneratorPostInitializationContext => incrementalGeneratorPostInitializationContext.AddSource("Attributes/ClassBlueprintAttribute.g.cs", SourceText.From(ClassBlueprintAttributeSourceCode, Encoding.UTF8)));

			
			blueprintFileProvider = context.AdditionalTextsProvider.Where(additionalText => Path.GetExtension(additionalText.Path) == ".bp")
			.Select((additionalText, cancellationToken) =>
				new Blueprint(Path.GetFileName(additionalText.Path), additionalText.GetText(cancellationToken)?.ToString()??"// No content")
			);


			#pragma warning disable CS8619 // La nullabilité des types référence dans la valeur ne correspond pas au type cible.
			typeDeclarationSyntaxProvider = context.SyntaxProvider.CreateSyntaxProvider
			(
				(syntaxNode, cancellationToken) => (syntaxNode is ClassDeclarationSyntax classDeclatationSyntax) ,
				transform: static (GeneratorSyntaxContext, _) => GeneratorSyntaxContext.Node as TypeDeclarationSyntax
			)
			.Where(typeDeclarationSyntax => typeDeclarationSyntax != null);
			#pragma warning restore CS8619 // La nullabilité des types référence dans la valeur ne correspond pas au type cible.


			IncrementalValueProvider<SourceContext> tempProvider = context.CompilationProvider
				.Combine(typeDeclarationSyntaxProvider.Collect())
				.Select((combined,cancelationToken)=> new SourceContext(combined.Left, combined.Right));

			IncrementalValueProvider<SourceContext> sourceContextProvider = 
				tempProvider.Combine(blueprintFileProvider.Collect())
				.Select((combined,cancellationToken)=> new SourceContext(combined.Left.Compilation, combined.Left.TypeDeclarations,combined.Right));



			context.RegisterSourceOutput
			(
				sourceContextProvider,
				(sourceProductionContext, sourceContext) => GenerateDynamicSources(context, sourceProductionContext, sourceContext)
			);

		}


		private static ProjectDefinition GenerateProjectDefinition(IncrementalGeneratorInitializationContext Context, SourceProductionContext SourceProductionContext,  SourceContext SourceContext)
		{
			INamedTypeSymbol? typeSymbol;
			string nameSpace;
			string className;

			ProjectDefinition projectDefinition ;
			ClassDefinition classDefinition;
			AttributeDefinition attributeDefinition;
			AttributeParameterDefinition attributeParameterDefinition; 


			projectDefinition = new ProjectDefinition();
			foreach (TypeDeclarationSyntax typeDeclaration in SourceContext.TypeDeclarations)
			{
				// On récupère le modèle sémantique pour pouvoir manipuler les méta données et le contenu de nos objets 
				typeSymbol = typeDeclaration.GetTypeSymbol<INamedTypeSymbol>(SourceContext.Compilation);
				if (typeSymbol == null) continue;

				// On récupère le namespace, le nom du noeud courant et on créé le nom du futur DTO
				nameSpace = typeSymbol.ContainingNamespace.ToDisplayString();
				className = typeDeclaration.Identifier.Text;
				classDefinition=new ClassDefinition(nameSpace, className);
				projectDefinition.Classes.Add(classDefinition);

				foreach (AttributeData attributeData in typeSymbol.GetAttributes())
				{
					if (attributeData.AttributeClass==null) continue;
					attributeDefinition = new AttributeDefinition(attributeData.AttributeClass.ToString());
					classDefinition.Attributes.Add(attributeDefinition);
					if (attributeData.AttributeConstructor == null) continue;

					for(int t=0;t< attributeData.AttributeConstructor.Parameters.Length;t++)
					{
						string parameterName= attributeData.AttributeConstructor.Parameters[t].Name;
						string? parameterValue = attributeData.ConstructorArguments[t].Value?.ToString();

						attributeParameterDefinition = new AttributeParameterDefinition(parameterName, parameterValue);
						attributeDefinition.Parameters.Add(attributeParameterDefinition);
					}

				}

			}

			return projectDefinition;
		}

		private void GenerateDynamicSources(IncrementalGeneratorInitializationContext Context, SourceProductionContext SourceProductionContext, SourceContext SourceContext)
		{
			Blueprint? blueprint;
			ProjectDefinition projectDefinition;
			string source;
			Scriban.Template template;

			projectDefinition=GenerateProjectDefinition(Context, SourceProductionContext, SourceContext );

			foreach (ClassDefinition classDefinition in projectDefinition.Classes)
			{
				foreach(AttributeDefinition attributeDefinition in classDefinition.Attributes.Where(item=>item.Name== "BlueprintLib.Attributes.ClassBlueprintAttribute"))
				{
					foreach (AttributeParameterDefinition attributeParameterDefinition in attributeDefinition.Parameters.Where(item => item.Name == "Name"))
					{
						blueprint = SourceContext.Blueprints.FirstOrDefault(item => item.FileName == attributeParameterDefinition.Value);


						if (blueprint == null) source = $"#warning Blueprint {attributeParameterDefinition.Value} was not found, please check if compilation action is set to additional files";
						else
						{
							template = Scriban.Template.Parse(blueprint.Content);
							source = template.Render(classDefinition);
						}
					
						SourceProductionContext.AddSource($"{classDefinition.Name}.{Path.GetFileNameWithoutExtension(attributeParameterDefinition.Value)}.g.cs", SourceText.From(source, Encoding.UTF8));

					}
				}
			}

			
        }

 

    }
}