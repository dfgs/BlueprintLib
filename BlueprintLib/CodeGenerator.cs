using BlueprintLib.Definitions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Scriban;
using Scriban.Runtime;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Xml.Linq;
using static System.Net.Mime.MediaTypeNames;


namespace BlueprintLib
{

	
	[Generator]
	public class CodeGenerator : IIncrementalGenerator
	{
		public const string Namespace = "BlueprintLib.Attributes";
		public const string ClassBlueprintAttributeName = "ClassBlueprintAttribute";
		public const string ClassBlueprintFullAttributeName = $"{Namespace}.ClassBlueprintAttribute";

		private string ClassBlueprintAttributeSourceCode =
        $$"""
		// <auto-generated/>
		using System;
		
		namespace {{Namespace}}
		{
			[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
			public class {{ClassBlueprintAttributeName}} : Attribute
			{
				public string Name
				{
					get;
					set;
				}
				public {{ClassBlueprintAttributeName}}(string Name)
				{
					this.Name=Name;
				}
			}
		}
		""";

        public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			IncrementalValuesProvider<Blueprint> blueprintFileProvider;
			IncrementalValuesProvider<TypeDeclarationSyntax> typeDeclarationSyntaxProvider;


			// register static files
			context.RegisterPostInitializationOutput(incrementalGeneratorPostInitializationContext => incrementalGeneratorPostInitializationContext.AddSource($"Attributes/{ClassBlueprintAttributeName}.g.cs", SourceText.From(ClassBlueprintAttributeSourceCode, Encoding.UTF8)));

			
			blueprintFileProvider = context.AdditionalTextsProvider.Where(additionalText => Path.GetExtension(additionalText.Path) == ".bp")
			.Select((additionalText, cancellationToken) =>
				new Blueprint(Path.GetFileName(additionalText.Path), additionalText.GetText(cancellationToken)?.ToString()??"// No content")
			);

			#pragma warning disable CS8619 // La nullabilité des types référence dans la valeur ne correspond pas au type cible.
			typeDeclarationSyntaxProvider = context.SyntaxProvider.CreateSyntaxProvider
			(
				(syntaxNode, cancellationToken) => (syntaxNode is ClassDeclarationSyntax classDeclatationSyntax) ,
				transform: static (GeneratorSyntaxContext, _) => GeneratorSyntaxContext.Node as TypeDeclarationSyntax
			)
			.Where(typeDeclarationSyntax => typeDeclarationSyntax != null);
			#pragma warning restore CS8619 // La nullabilité des types référence dans la valeur ne correspond pas au type cible.

			IncrementalValueProvider<ProjectDefinition> projectDefinitionProvider =
				context.CompilationProvider
				.Combine(typeDeclarationSyntaxProvider.Collect())
				.Select((combined, cancelationToken) => GenerateProjectDefinition(combined.Left, combined.Right));

			IncrementalValueProvider<(ProjectDefinition ProjectDefinition, ImmutableArray<Blueprint> Blueprints)> sourceContextProvider =
				projectDefinitionProvider.
				Combine(blueprintFileProvider.Collect())
				.Select((combined, cancellationToken) => (combined.Left, combined.Right));

			context.RegisterSourceOutput
			(
				sourceContextProvider,
				(sourceProductionContext, combined) => GenerateDynamicSources(sourceProductionContext, combined.ProjectDefinition, combined.Blueprints)
			);

		}

		private static IEnumerable<AttributeDefinition> GenerateAttributeDefinitions(ISymbol Symbol) 
		{
			AttributeDefinition attributeDefinition;
			AttributeParameterDefinition attributeParameterDefinition;

			foreach (AttributeData attributeData in Symbol.GetAttributes())
			{
				if (attributeData.AttributeClass == null) continue;
				attributeDefinition = new AttributeDefinition(attributeData.AttributeClass.ToString());
				if (attributeData.AttributeConstructor != null)
				{
					for (int t = 0; t < attributeData.AttributeConstructor.Parameters.Length; t++)
					{
						string parameterName = attributeData.AttributeConstructor.Parameters[t].Name;
						string? parameterValue = attributeData.ConstructorArguments[t].Value?.ToString();

						attributeParameterDefinition = new AttributeParameterDefinition(parameterName, parameterValue);
						attributeDefinition.Parameters.Add(attributeParameterDefinition);
					}
				}
				yield return attributeDefinition;
			}
		}
		private static IEnumerable<PropertyDefinition> GeneratePropertyDefinitions(INamedTypeSymbol TypeSymbol)
		{
			PropertyDefinition propertyDefinition;
			

			foreach (IPropertySymbol propertySymbol in TypeSymbol.GetMembers().OfType<IPropertySymbol>())
			{
				propertyDefinition = new PropertyDefinition(propertySymbol.Name,propertySymbol.Type.ToString());
				propertyDefinition.Attributes.AddRange(GenerateAttributeDefinitions(propertySymbol));
				yield return propertyDefinition;
			}
		}

		private static ProjectDefinition GenerateProjectDefinition(Compilation Compilation, ImmutableArray<TypeDeclarationSyntax> TypeDeclarations )
		{
			INamedTypeSymbol? typeSymbol;
			string nameSpace;
			string className;

			ProjectDefinition projectDefinition ;
			ClassDefinition classDefinition;


			projectDefinition = new ProjectDefinition();
			foreach (TypeDeclarationSyntax typeDeclaration in TypeDeclarations)
			{
				// On récupère le modèle sémantique pour pouvoir manipuler les méta données et le contenu de nos objets 
				typeSymbol = typeDeclaration.GetTypeSymbol<INamedTypeSymbol>(Compilation);
				if (typeSymbol == null) continue;

				// On récupère le namespace, le nom du noeud courant et on créé le nom du futur DTO
				nameSpace = typeSymbol.ContainingNamespace.ToDisplayString();
				className = typeDeclaration.Identifier.Text;
				classDefinition=new ClassDefinition(nameSpace, className);
				projectDefinition.Classes.Add(classDefinition);

				classDefinition.Attributes.AddRange(GenerateAttributeDefinitions(typeSymbol));
				classDefinition.Properties.AddRange(GeneratePropertyDefinitions(typeSymbol));
			}

			return projectDefinition;
		}

		private void GenerateDynamicSources(SourceProductionContext SourceProductionContext,ProjectDefinition ProjectDefinition, ImmutableArray<Blueprint> Blueprints)
		{
			Blueprint? blueprint;
			string source;
			Scriban.Template template;
			TemplateContext templateContext;
			ScriptObject scriptObject;


			foreach (ClassDefinition classDefinition in ProjectDefinition.Classes)
			{
				foreach(AttributeDefinition attributeDefinition in classDefinition.Attributes.Where(item=>item.Name== ClassBlueprintFullAttributeName))
				{
					foreach (AttributeParameterDefinition attributeParameterDefinition in attributeDefinition.Parameters.Where(item => item.Name == "Name"))
					{
						blueprint = Blueprints.FirstOrDefault(item => item.FileName == attributeParameterDefinition.Value);


						if (blueprint == null) source = $"#warning Blueprint {attributeParameterDefinition.Value} was not found, please check if compilation action is set to additional files";
						else
						{
							scriptObject = new ScriptObject();
							scriptObject.Add("class", classDefinition);
							// Declare a function `myfunc` returning the string `Yes`
							scriptObject.Import("contains", new Func<IEnumerable<AttributeDefinition> ,string, bool>((attributes,name) => attributes.Any(item=>item.Name==name) ));

							templateContext = new TemplateContext();
							templateContext.PushGlobal(scriptObject);



							template = Scriban.Template.ParseLiquid(blueprint.Content);
							source = template.Render(templateContext);
						}
					
						SourceProductionContext.AddSource($"{classDefinition.Name}.{Path.GetFileNameWithoutExtension(attributeParameterDefinition.Value)}.g.cs", SourceText.From(source, Encoding.UTF8));

					}
				}
			}

			
        }

 

    }
}