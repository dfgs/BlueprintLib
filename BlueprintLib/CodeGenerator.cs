using BlueprintLib.Definitions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Scriban;
using Scriban.Runtime;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.Linq;
using System.Reflection.Metadata;
using System.Runtime.CompilerServices;
using System.Text;
using System.Xml.Linq;
using static System.Net.Mime.MediaTypeNames;


namespace BlueprintLib
{

	
	[Generator]
	public class CodeGenerator : IIncrementalGenerator
	{
		public const string Namespace = "BlueprintLib.Attributes";
		public const string BlueprintAttributeName = "BlueprintAttribute";
		public const string BlueprintFullAttributeName = $"{Namespace}.{BlueprintAttributeName}";

		private string BlueprintAttributeSourceCode =
        $$"""
		// <auto-generated/>
		using System;
		
		namespace {{Namespace}}
		{
			[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
			public class {{BlueprintAttributeName}} : Attribute
			{
				public string Name
				{
					get;
					set;
				}
				public {{BlueprintAttributeName}}(string Name)
				{
					this.Name=Name;
				}
			}
		}
		""";

        public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			IncrementalValuesProvider<Blueprint> blueprintFileProvider;
			IncrementalValuesProvider<TypeDeclarationSyntax> typeDeclarationSyntaxProvider;


			// register static files
			context.RegisterPostInitializationOutput(incrementalGeneratorPostInitializationContext => incrementalGeneratorPostInitializationContext.AddSource($"Attributes/{BlueprintAttributeName}.g.cs", SourceText.From(BlueprintAttributeSourceCode, Encoding.UTF8)));

		
			blueprintFileProvider = context.AdditionalTextsProvider.Where(additionalText => Path.GetExtension(additionalText.Path) == ".bp")
			.Select((additionalText, cancellationToken) =>
				new Blueprint(Path.GetFileName(additionalText.Path), additionalText.GetText(cancellationToken)?.ToString()??"// No content")
			);

			#pragma warning disable CS8619 // La nullabilité des types référence dans la valeur ne correspond pas au type cible.
			typeDeclarationSyntaxProvider = context.SyntaxProvider.CreateSyntaxProvider
			(
				(syntaxNode, cancellationToken) => (syntaxNode is ClassDeclarationSyntax classDeclatationSyntax) ,
				transform: static (GeneratorSyntaxContext, _) => GeneratorSyntaxContext.Node as TypeDeclarationSyntax
			)
			.Where(typeDeclarationSyntax => typeDeclarationSyntax != null);
			#pragma warning restore CS8619 // La nullabilité des types référence dans la valeur ne correspond pas au type cible.

			IncrementalValueProvider<ProjectDefinition> projectDefinitionProvider =
				context.CompilationProvider
				.Combine(typeDeclarationSyntaxProvider.Collect())
				.Select((combined, cancelationToken) => GenerateProjectDefinition(combined.Left, combined.Right));

			IncrementalValueProvider<(ProjectDefinition ProjectDefinition, ImmutableArray<Blueprint> Blueprints)> sourceContextProvider =
				projectDefinitionProvider.
				Combine(blueprintFileProvider.Collect())
				.Select((combined, cancellationToken) => (combined.Left, combined.Right));

			context.RegisterSourceOutput
			(
				sourceContextProvider,
				(sourceProductionContext, combined) => GenerateDynamicSources(sourceProductionContext, combined.ProjectDefinition, combined.Blueprints)
			);

		}

		private static IEnumerable<AttributeDefinition> GenerateAttributeDefinitions(ISymbol Symbol) 
		{
			AttributeDefinition attributeDefinition;
			AttributeParameterDefinition attributeParameterDefinition;

			foreach (AttributeData attributeData in Symbol.GetAttributes())
			{
				if (attributeData.AttributeClass == null) continue;
				attributeDefinition = new AttributeDefinition(attributeData.AttributeClass.ToString());

				if (attributeData.AttributeConstructor != null)
				{
					for (int t = 0; t < attributeData.AttributeConstructor.Parameters.Length; t++)
					{
						string parameterName = attributeData.AttributeConstructor.Parameters[t].Name;
						string? parameterValue = attributeData.ConstructorArguments[t].Value?.ToString();

						attributeParameterDefinition = new AttributeParameterDefinition(parameterName, parameterValue);
						attributeDefinition.Parameters.Add(attributeParameterDefinition);
					}
				}
				foreach (KeyValuePair<string, TypedConstant> namedArgument in attributeData.NamedArguments)
				{
					string parameterName = namedArgument.Key;
					string? parameterValue = namedArgument.Value.Value?.ToString();

					attributeParameterDefinition = new AttributeParameterDefinition(parameterName, parameterValue);
					attributeDefinition.Parameters.Add(attributeParameterDefinition);
				}

				yield return attributeDefinition;
			}
		}
		private static IEnumerable<PropertyDefinition> GeneratePropertyDefinitions(INamedTypeSymbol TypeSymbol)
		{
			PropertyDefinition propertyDefinition;
			

			foreach (IPropertySymbol propertySymbol in TypeSymbol.GetMembers().OfType<IPropertySymbol>())
			{
				propertyDefinition = new PropertyDefinition(propertySymbol.Name,propertySymbol.Type.ToString());
				propertyDefinition.Attributes.AddRange(GenerateAttributeDefinitions(propertySymbol));
				yield return propertyDefinition;
			}
		}

		private static ProjectDefinition GenerateProjectDefinition(Compilation Compilation, ImmutableArray<TypeDeclarationSyntax> TypeDeclarations )
		{
			INamedTypeSymbol? typeSymbol;
			string nameSpace;
			string className;

			ProjectDefinition projectDefinition ;
			ClassDefinition classDefinition;


			projectDefinition = new ProjectDefinition(Compilation.AssemblyName??"noname");
			

			foreach (TypeDeclarationSyntax typeDeclaration in TypeDeclarations)
			{
				// On récupère le modèle sémantique pour pouvoir manipuler les méta données et le contenu de nos objets 
				typeSymbol = typeDeclaration.GetTypeSymbol<INamedTypeSymbol>(Compilation);
				if (typeSymbol == null) continue;

				// On récupère le namespace, le nom du noeud courant et on créé le nom du futur DTO
				nameSpace = typeSymbol.ContainingNamespace.ToDisplayString();
				className = typeDeclaration.Identifier.Text;
				classDefinition=new ClassDefinition(nameSpace, className);
				projectDefinition.Classes.Add(classDefinition);

				classDefinition.Attributes.AddRange(GenerateAttributeDefinitions(typeSymbol));
				classDefinition.Properties.AddRange(GeneratePropertyDefinitions(typeSymbol));
			}

			return projectDefinition;
		}

		private static string GenerateSourceContent(string TemplateContent, TemplateContext TemplateContext)
		{
			string source;

			Template template = Scriban.Template.ParseLiquid(TemplateContent);
			if (template.HasErrors) source = $"/* \r\nErrors found in blueprint:\r\n{template.Messages.ToString()}\r\n*/";
			else
			{
				try
				{
					source = template.Render(TemplateContext);
				}
				catch (Exception e)
				{
					source = $"/* \r\nErrors found in blueprint:\r\n{e.Message}\r\n*/";
				}

			}

			return source;
		}
		private void GenerateDynamicSources(SourceProductionContext SourceProductionContext,ProjectDefinition ProjectDefinition, ImmutableArray<Blueprint> Blueprints)
		{
			Blueprint? blueprint;
			string source;
			TemplateContext templateContext;
			ScriptObject scriptObject;


			templateContext = new TemplateContext();

			scriptObject = new ScriptObject();
			// Declare a functions
			scriptObject.Import("find", new Func<IEnumerable<AttributeDefinition>, string, AttributeDefinition>((attributes, name) => attributes.FirstOrDefault(item => (item.Name == name) || (item.Name.Split('.').Last() == name))));
			scriptObject.Import("contains", new Func<IEnumerable<AttributeDefinition>, string, bool>((attributes, name) => attributes.Any(item => (item.Name == name) || (item.Name.Split('.').Last()==name) )));

			scriptObject.Add("project", ProjectDefinition);

			templateContext.PushGlobal(scriptObject);

			// generate source files from project definition
			foreach (ClassDefinition classDefinition in ProjectDefinition.Classes)
			{
				foreach(AttributeDefinition attributeDefinition in classDefinition.Attributes.Where(item=>item.Name == BlueprintFullAttributeName))
				{
					foreach (AttributeParameterDefinition attributeParameterDefinition in attributeDefinition.Parameters.Where(item => item.Name == "Name"))
					{
						blueprint = Blueprints.FirstOrDefault(item => item.FileName == attributeParameterDefinition.Value);

						if (blueprint == null) source = $"#warning Blueprint {attributeParameterDefinition.Value} was not found, please check if compilation action is set to additional files";
						else
						{
							scriptObject.Remove("class");
							scriptObject.Add("class", classDefinition);

							source = GenerateSourceContent(blueprint.Content, templateContext);
						}
					
						SourceProductionContext.AddSource($"{classDefinition.Name}.{Path.GetFileNameWithoutExtension(attributeParameterDefinition.Value)}.g.cs", SourceText.From(source, Encoding.UTF8));

					}
				}
			}

			
        }

 

    }
}