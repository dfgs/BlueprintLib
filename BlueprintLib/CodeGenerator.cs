using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Xml.Linq;
using static System.Net.Mime.MediaTypeNames;

namespace BlueprintLib
{

	
	[Generator]
	public class CodeGenerator : IIncrementalGenerator
	{
		
        private const string ClassBlueprintAttributeSourceCode =
        $$"""
		// <auto-generated/>
		using System;
		
		namespace BlueprintLib.Attributes
		{
			[AttributeUsage(AttributeTargets.Class)]
			public class ClassBlueprintAttribute : Attribute
			{
				public string Name
				{
					get;
					set;
				}
				public ClassBlueprintAttribute(string Name)
				{
					this.Name=Name;
				}
			}
		}
		""";

        public void Initialize(IncrementalGeneratorInitializationContext context)
		{
            IncrementalValuesProvider<TypeDeclarationSyntax?> syntaxNodeProvider;

			Debugger.Break();

			// register static files
			context.RegisterPostInitializationOutput(incrementalGeneratorPostInitializationContext => incrementalGeneratorPostInitializationContext.AddSource("Attributes/BlueprintAttribute.g.cs", SourceText.From(ClassBlueprintAttributeSourceCode, Encoding.UTF8)));

            /*var someInfo = context.AnalyzerConfigOptionsProvider
			.Select(static (ctx, _) => {
				if (ctx.GlobalOptions.TryGetValue("build_property.someInfo", out var info))
				{
					return info;
				}
				return null;
			});*/

            var blueprintFileProvider = context.AdditionalTextsProvider.Where(additionalText => Path.GetExtension(additionalText.Path)==".bp").Select((additionalText, cancellationToken) => additionalText.GetText(cancellationToken)!.ToString());


			syntaxNodeProvider = context.SyntaxProvider.CreateSyntaxProvider
			(
				(syntaxNode, cancellationToken) => (syntaxNode is ClassDeclarationSyntax classDeclatationSyntax) /*&& (classDeclatationSyntax.ContainsAttribute("BlueprintLib.Attributes.ClassBlueprintAttribute"))*/,
				transform: static (GeneratorSyntaxContext, _) => GeneratorSyntaxContext.Node as TypeDeclarationSyntax
			)
			.Where(classDeclarationSyntax => classDeclarationSyntax != null);
			


			IncrementalValueProvider<(Compilation Compilation,ImmutableArray<TypeDeclarationSyntax?> Right)> syntaxNodeWithCompilationtest = context.CompilationProvider.Combine(syntaxNodeProvider.Collect());
			
			//var source = context.CompilationProvider.Combine(syntaxNodeProvider.Collect());
            
            context.RegisterSourceOutput
			(
                syntaxNodeWithCompilationtest,
				(sourceProductionContext, source) => GenerateDynamicSources(context,sourceProductionContext, source.Compilation,source.Right)
			);

			

			
		}





		/*private static (SyntaxNode Node, string TemplateName)? GetSyntaxNodesWithBluePrintAttribute(GeneratorSyntaxContext GeneratorSyntaxContext)
		{
            TypeDeclarationSyntax? classDeclarationSyntax;
            INamedTypeSymbol? typeSymbol;

            AttributeData? attributeData;
            string? templateName;


            classDeclarationSyntax = GeneratorSyntaxContext.Node as TypeDeclarationSyntax;
			if (classDeclarationSyntax == null) return null;

            // On récupère le modèle sémantique pour pouvoir manipuler les méta données et le contenu de nos objets 
            typeSymbol = classDeclarationSyntax.GetTypeSymbol<INamedTypeSymbol>(compilation);
            if (typeSymbol == null) return null;

            attributeData = typeSymbol.GetAttribute("BlueprintLib.Attributes.ClassBlueprintAttribute");
            if ((attributeData == null) || (attributeData.ConstructorArguments.Length == 0)) return;

            templateName = attributeData.ConstructorArguments[0].Value?.ToString();
            if (templateName == null) return;


            if (currentNode.ContainsAttribute(GeneratorSyntaxContext.SemanticModel, $"BlueprintLib.Attributes.ClassBlueprintAttribute")) return (currentNode, SourceGenerationType.Class);
			//if (currentNode.ContainsAttribute(context.SemanticModel, $"{Namespace}.DatabaseAttribute")) return (currentNode, DataModelType.Database);

			return (currentNode, SourceGenerationType.Ignore);
		}*/

		private void GenerateDynamicSources(IncrementalGeneratorInitializationContext context, SourceProductionContext sourceProductionContext, Compilation compilation, IEnumerable<TypeDeclarationSyntax?> Declarations)
		{
			foreach(TypeDeclarationSyntax? declaration in Declarations)
			{
				GenerateClassDynamicSources(context,sourceProductionContext, compilation,declaration); 
			}
        }

        private void GenerateClassDynamicSources(IncrementalGeneratorInitializationContext context, SourceProductionContext sourceProductionContext, Compilation compilation, TypeDeclarationSyntax? ClassDeclarationSyntax)
        {
            INamedTypeSymbol? typeSymbol;
            string nameSpace;
			string className;

			AttributeData? attributeData;
			string? templateName;
            string source;


            if (ClassDeclarationSyntax == null) return;

            //Template template = Template.ParseLiquid(TemplateSource);
            /*
            // Parse a liquid template
            IncrementalValuesProvider<string> blueprints = context.AdditionalTextsProvider.Where(additionalText => additionalText.Path.EndsWith("blueprintAttribute.bp")).Select((additionalText,cancellationToken) => additionalText.GetText(cancellationToken)!.ToString());
            context.RegisterSourceOutput(blueprints, (context, TemplateSource) =>context.AddSource("test.cs",  SourceText.From(GenerateSourceCodeFromTemplate( TemplateSource), Encoding.UTF8) ));
			*/

            // On récupère le modèle sémantique pour pouvoir manipuler les méta données et le contenu de nos objets 
            typeSymbol = ClassDeclarationSyntax.GetTypeSymbol<INamedTypeSymbol>(compilation);
            if (typeSymbol == null) return;

            // On récupère le namespace, le nom du noeud courant et on créé le nom du futur DTO
            nameSpace = typeSymbol.ContainingNamespace.ToDisplayString();
            className = ClassDeclarationSyntax.Identifier.Text;

			
			var test = context.AdditionalTextsProvider.Where(additionalText=>additionalText.Path!=null);

			attributeData = typeSymbol.GetAttribute("BlueprintLib.Attributes.ClassBlueprintAttribute");
            if ((attributeData == null) || (attributeData.ConstructorArguments.Length==0)) return;
            
			templateName = attributeData.ConstructorArguments[0].Value?.ToString();
			if (templateName == null) return;

			using (FileStream stream = new FileStream(templateName, FileMode.Open))
			{
				TextReader reader = new StreamReader(stream);
				source= reader.ReadToEnd();
			}
			
            //source = $"// {templateName}";
            sourceProductionContext.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));

        }


    }
}