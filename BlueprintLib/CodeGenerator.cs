using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Xml.Linq;
using static System.Net.Mime.MediaTypeNames;

namespace BlueprintLib
{

	
	[Generator]
	public class CodeGenerator : IIncrementalGenerator
	{
		
        private const string ClassBlueprintAttributeSourceCode =
        $$"""
		// <auto-generated/>
		using System;
		
		namespace BlueprintLib.Attributes
		{
			[AttributeUsage(AttributeTargets.Class)]
			public class ClassBlueprintAttribute : Attribute
			{
				public string Name
				{
					get;
					set;
				}
				public ClassBlueprintAttribute(string Name)
				{
					this.Name=Name;
				}
			}
		}
		""";

        public void Initialize(IncrementalGeneratorInitializationContext context)
		{
            IncrementalValuesProvider<TypeDeclarationSyntax?> syntaxNodeProvider;

			IncrementalValuesProvider<(string FileName,string Content)> blueprintFileProvider;

			// register static files
			context.RegisterPostInitializationOutput(incrementalGeneratorPostInitializationContext => incrementalGeneratorPostInitializationContext.AddSource("Attributes/BlueprintAttribute.g.cs", SourceText.From(ClassBlueprintAttributeSourceCode, Encoding.UTF8)));

			
			blueprintFileProvider = context.AdditionalTextsProvider.Where(additionalText =>
			Path.GetExtension(additionalText.Path) == ".bp")
				.Select((additionalText, cancellationToken) =>
				(Path.GetFileName(additionalText.Path), additionalText.GetText(cancellationToken)!.ToString())
				);
			

			syntaxNodeProvider = context.SyntaxProvider.CreateSyntaxProvider
			(
				(syntaxNode, cancellationToken) => (syntaxNode is ClassDeclarationSyntax classDeclatationSyntax) ,
				transform: static (GeneratorSyntaxContext, _) => GeneratorSyntaxContext.Node as TypeDeclarationSyntax
			)
			.Where(classDeclarationSyntax => classDeclarationSyntax != null);



			IncrementalValueProvider<((Compilation Compilation, ImmutableArray<TypeDeclarationSyntax?> ClassDeclarationSyntaxArray) CompilationAndClassDeclarationSyntaxArray, ImmutableArray<(string FileName, string Content)> BlueprintFileNamesArray)> syntaxNodeWithCompilationtest = 
				context.CompilationProvider.Combine(syntaxNodeProvider.Collect())
				.Combine(blueprintFileProvider.Collect())
				;
			
            
            context.RegisterSourceOutput
			(
                syntaxNodeWithCompilationtest,
				(sourceProductionContext, source) => GenerateDynamicSources(context,sourceProductionContext, source.CompilationAndClassDeclarationSyntaxArray.Compilation,source.CompilationAndClassDeclarationSyntaxArray.ClassDeclarationSyntaxArray,source.BlueprintFileNamesArray)
			);





		}





		/*private static (SyntaxNode Node, string TemplateName)? GetSyntaxNodesWithBluePrintAttribute(GeneratorSyntaxContext GeneratorSyntaxContext)
		{
            TypeDeclarationSyntax? classDeclarationSyntax;
            INamedTypeSymbol? typeSymbol;

            AttributeData? attributeData;
            string? templateName;


            classDeclarationSyntax = GeneratorSyntaxContext.Node as TypeDeclarationSyntax;
			if (classDeclarationSyntax == null) return null;

            // On récupère le modèle sémantique pour pouvoir manipuler les méta données et le contenu de nos objets 
            typeSymbol = classDeclarationSyntax.GetTypeSymbol<INamedTypeSymbol>(compilation);
            if (typeSymbol == null) return null;

            attributeData = typeSymbol.GetAttribute("BlueprintLib.Attributes.ClassBlueprintAttribute");
            if ((attributeData == null) || (attributeData.ConstructorArguments.Length == 0)) return;

            templateName = attributeData.ConstructorArguments[0].Value?.ToString();
            if (templateName == null) return;


            if (currentNode.ContainsAttribute(GeneratorSyntaxContext.SemanticModel, $"BlueprintLib.Attributes.ClassBlueprintAttribute")) return (currentNode, SourceGenerationType.Class);
			//if (currentNode.ContainsAttribute(context.SemanticModel, $"{Namespace}.DatabaseAttribute")) return (currentNode, DataModelType.Database);

			return (currentNode, SourceGenerationType.Ignore);
		}*/

		private void GenerateDynamicSources(IncrementalGeneratorInitializationContext context, SourceProductionContext sourceProductionContext, Compilation compilation, IEnumerable<TypeDeclarationSyntax?> Declarations, IEnumerable<(string FileName, string Content)> Blueprints)
		{
			foreach(TypeDeclarationSyntax? declaration in Declarations)
			{
				GenerateClassDynamicSources(context,sourceProductionContext, compilation,declaration, Blueprints); 
			}
        }

        private void GenerateClassDynamicSources(IncrementalGeneratorInitializationContext context, SourceProductionContext sourceProductionContext, Compilation compilation, TypeDeclarationSyntax? ClassDeclarationSyntax, IEnumerable<(string FileName, string Content)> Blueprints)
        {
            INamedTypeSymbol? typeSymbol;
            string nameSpace;
			string className;

			string? templateName;
            string source;
			string? template;


            if (ClassDeclarationSyntax == null) return;

			// On récupère le modèle sémantique pour pouvoir manipuler les méta données et le contenu de nos objets 
			typeSymbol = ClassDeclarationSyntax.GetTypeSymbol<INamedTypeSymbol>(compilation);
            if (typeSymbol == null) return;


			templateName = typeSymbol.GetTemplateName();
			if (templateName == null) return;

			template = Blueprints.FirstOrDefault(item => item.FileName == templateName).Content;
			if (template == null) return;

			// Parse a liquid template
			//Template template = Template.ParseLiquid(TemplateSource);

			// On récupère le namespace, le nom du noeud courant et on créé le nom du futur DTO
			nameSpace = typeSymbol.ContainingNamespace.ToDisplayString();
            className = ClassDeclarationSyntax.Identifier.Text;
			
            source = template;
            sourceProductionContext.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));

        }


    }
}